package cs2030s.fp;

import java.util.ArrayList;
import java.util.List;

/**
 * A class that represents an infinite list of elements of type {@code T}.
 * The list is generated lazily, and its elements are computed as needed.
 *
 * @param <T> the type of elements in the infinite list
 */
public class InfiniteList<T> {
  /**
   * Head of the list is a Maybe that is Lazy.
   */
  private final Lazy<Maybe<T>> head;
  /**
   * Tail of the list is another infiniteList that is lazy.
   */
  private final Lazy<InfiniteList<T>> tail;
  /**
   * There is only one Sentinel, thus it is a class field.
   */
  private static final Sentinel SENTINEL = new Sentinel();

  /**
   * Constructs an empty InfiniteList.
   */
  private InfiniteList() { 
    this.head = null; 
    this.tail = null;
  }

  /**
   * Creates an InfiniteList by generating its elements using the given {@code Producer}.
   *
   * @param producer the producer function used to generate elements of the list
   * @param <T>      the type of elements in the infinite list
   * @return an InfiniteList generated using the producer function
   */
  public static <T> InfiniteList<T> generate(Producer<T> producer) {
    return new InfiniteList<>(
        Lazy.of(() -> Maybe.some(producer.produce())), 
        Lazy.of(() -> generate(producer))
        );
  }

  /**
   * Creates an InfiniteList by iteratively applying the {@code Transformer} to the seed value.
   *
   * @param seed  the initial value of the list
   * @param next  the transformer function to generate the next element in the list
   * @param <T>   the type of elements in the infinite list
   * @return an InfiniteList generated by applying the transformer to the seed
   */
  public static <T> InfiniteList<T> iterate(T seed, Transformer<T, T> next) {
    return new InfiniteList<>(seed, () -> iterate(next.transform(seed), next));
  }

  /**
   * Constructs an InfiniteList with the specified head element and tail producer.
   *
   * @param head  the head element of the list
   * @param tail  the producer function to generate the tail of the list
   */
  private InfiniteList(T head, Producer<InfiniteList<T>> tail) {
    this.head = Lazy.of(Maybe.some(head));
    this.tail = Lazy.of(tail);
  }

  /**
   * Constructs an InfiniteList with the specified lazy head and tail.
   *
   * @param head  the lazy head element of the list
   * @param tail  the lazy tail of the list
   */
  private InfiniteList(Lazy<Maybe<T>> head, Lazy<InfiniteList<T>> tail) {
    this.head = head;
    this.tail = tail;
  }

  /**
   * Returns the head element of this InfiniteList.
   *
   * @return the head element of this InfiniteList
   */
  public T head() {
    return this.head.get().orElseGet(() -> this.tail.get().head());
  }

  /**
   * Returns the tail of this InfiniteList.
   *
   * @return the tail of this InfiniteList
   */
  public InfiniteList<T> tail() {
    return this.head.get()
      .map(x -> this.tail.get())
      .orElseGet(() -> this.tail.get().tail());
  }

  /**
   * Transforms the elements in this InfiniteList using the given mapper function.
   *
   * @param mapper The transformation function to be applied to each element.
   * @param <R> The type of the elements in the resulting InfiniteList.
   * @return A new InfiniteList with transformed elements.
   */
  public <R> InfiniteList<R> map(Transformer<? super T, ? extends R> mapper) {
    return new InfiniteList<R>(
        Lazy.of(() -> this.head.get().map(mapper)), 
        Lazy.of(() -> this.tail.get().map(mapper))
        );
  }

  /**
   * Filters the elements in this InfiniteList using the given predicate.
   *
   * @param predicate The predicate used to filter the elements.
   * @return A new InfiniteList with only the elements that satisfy the predicate.
   */
  public InfiniteList<T> filter(BooleanCondition<? super T> predicate) {
    return new InfiniteList<>(
        Lazy.of(() -> this.head.get().filter(predicate)), 
        Lazy.of(() -> this.tail.get().filter(predicate))
        );
  }

  /**
   * Creates a sentinel that acts as an "empty" InfiniteList. This is used to denote
   * the end of a finite infiniteList.
   *
   * @param <T> The type of the elements in the InfiniteList.
   * @return An empty InfiniteList instance.
   */
  public static <T> InfiniteList<T> sentinel() {
    @SuppressWarnings("unchecked")
    InfiniteList<T> temp = (InfiniteList<T>) SENTINEL;
    return temp;
  }

  /**
   * Determines if the current InfiniteList is a sentinel (end of list).
   *
   * @return true if the current InfiniteList is a sentinel, false otherwise.
   */
  public boolean isSentinel() {
    return false;
  }

  /**
   * Limits the size of the current InfiniteList to the specified number of elements.
   * Nulls (or Maybe.None()) are not considered. Thus if it is a none, we recurse to
   * the tail with the same n.
   *
   * @param n The number of elements to limit the list to.
   * @return A new InfiniteList with a maximum of n elements.
   */
  public InfiniteList<T> limit(long n) {
    return n <= 0
      ? sentinel()
      : new InfiniteList<>(
          this.head, 
          Lazy.of(() -> this.head.get()
            .map(x -> this.tail.get().limit(n - 1))
            .orElseGet(() -> this.tail.get().limit(n)))
          );
  }

  /**
   * Truncates the InfiniteList when the first element that does not satisfy the given 
   * predicate is encountered. Nulls are not considered. If current head is a null, we continue. 
   * If current head is not null and the predicate is true, we continue and the value is kept. 
   * In either case, if the before value is the same as the value after filter, we will continue. 
   * Only if there is a change (value converted to null if predicate not satisfied), we will end.
   *
   * @param predicate The predicate used to determine when to truncate the list.
   * @return A new InfiniteList truncated based on the predicate.
   */
  public InfiniteList<T> takeWhile(BooleanCondition<? super T> predicate) {
    Lazy<Maybe<T>> filtered = Lazy.of(() -> this.head.get().filter(predicate));
    return new InfiniteList<>(
        filtered,
        Lazy.of(
          () -> filtered.equals(this.head) 
          ? this.tail.get().takeWhile(predicate) 
          : sentinel()
          )
    );
  }

  /**
   * Reduces the elements of this InfiniteList by successively combining each element 
   * with an accumulator. We only accunulate if the current head is not a null. In either case, 
   * we will recurse the tail until the end of the list. Since the combiner method of the Lazy 
   * class takes in a Lazy value. We have to convert the Lazy Maybe value to a Lazy value. 
   *
   * @param identity The initial value for the accumulator.
   * @param accumulator The function that combines the accumulator with an element.
   * @param <U> The type of the accumulator and the resulting value.
   * @return The result of applying the accumulator function to the elements of the list.
   */
  public <U> U reduce(U identity, Combiner<U, ? super T, U> accumulator) {
    if (this.isSentinel()) {
      return identity;
    } else {
      /*
      Lazy<U> accumulated = Lazy.of(identity);
      if (this.head.get().map(x -> true).orElse(false)) {
        accumulated = Lazy.of(identity).combine(Lazy.of(this.head.get().get()), accumulator);
      }
      return this.tail.get().reduce(accumulated.get(), accumulator);
      */
      Lazy<U> accumulated = this.head.get()
          .map(headValue -> Lazy.of(identity).combine(Lazy.of(headValue), accumulator))
          .orElse(Lazy.of(identity));
      return this.tail.get().reduce(accumulated.get(), accumulator);
    }
  }

  /**
   * Counts the number of elements in this InfiniteList. Nulls are skipped.
   *
   * @return The number of elements in the list.
   */
  public long count() {
    return this.isSentinel()
      ? 0
      : this.head.get().map(x -> true).orElse(false)
      ? 1 + this.tail.get().count()
      : 0 + this.tail.get().count();
  }

  /**
   * Converts this InfiniteList into a List of elements. We add if it is not a null. We stop
   * when we reach the end of the list.
   *
   * @return A List containing the elements of this InfiniteList.
   */
  public List<T> toList() {
    List<T> newList = new ArrayList<T>();
    InfiniteList<T> curList = this;
    while (!curList.isSentinel()) {
      /*
      if (curList.head.get().map(x -> true).orElse(false)) {
        T curObj = curList.head.get().get();
        newList.add(curObj);
      }
      */
      curList.head.get().ifPresent(x -> newList.add(x));
      curList = curList.tail.get();
    }
    return newList;
  }

  /**
   * Returns the string representation of this InfiniteList.
   *
   * @return A string representation of the list.
   */
  public String toString() {
    return "[" + this.head + " " + this.tail + "]";
  }

  /**
   * A private static class that represents the sentinel (empty list) in the InfiniteList class.
   * This class extends the InfiniteList class, overriding certain methods to 
   * provide sentinel-specific behavior.
   */
  private static class Sentinel extends InfiniteList<Object> {
    /**
     * Returns the string representation of the sentinel.
     *
     * @return A string representation of the sentinel.
     */
    @Override
    public String toString() {
      return "-";
    }

    /**
     * Determines if the current InfiniteList is a sentinel (empty list).
     *
     * @return true if the current InfiniteList is a sentinel, false otherwise.
     */
    @Override
    public boolean isSentinel() {
      return true;
    }

    /**
     * Throws a NoSuchElementException when trying to access the head of the sentinel.
     *
     * @return Nothing; this method always throws an exception.
     */
    @Override
    public Object head() {
      throw new java.util.NoSuchElementException();
    }

    /**
     * Throws a NoSuchElementException when trying to access the tail of the sentinel.
     *
     * @return Nothing; this method always throws an exception.
     */
    @Override
    public InfiniteList<Object> tail() {
      throw new java.util.NoSuchElementException();
    }

    /**
     * Overrides the map method for the sentinel, returning the sentinel itself.
     *
     * @param mapper The transformation function to be applied to each element.
     * @param <R> The type of the elements in the resulting InfiniteList.
     * @return The sentinel instance itself.
     */
    @Override
    public <R> InfiniteList<R> map(Transformer<? super Object, ? extends R> mapper) {
      return this.sentinel();
    }

    /**
     * Overrides the filter method for the sentinel, returning the sentinel itself.
     *
     * @param predicate The predicate used to filter the elements.
     * @return The sentinel instance itself.
     */
    @Override
    public InfiniteList<Object> filter(BooleanCondition<? super Object> predicate) {
      return this;
    }

    /**
     * Overrides the limit method for the sentinel, returning the sentinel itself.
     *
     * @param n The number of elements to limit the list to.
     * @return The sentinel instance itself.
     */
    @Override
    public InfiniteList<Object> limit(long n) {
      return this;
    }

    /**
     * Overrides the takeWhile method for the sentinel, returning the sentinel itself.
     *
     * @param predicate The predicate used to determine when to truncate the list.
     * @return The sentinel instance itself.
     */
    @Override
    public InfiniteList<Object> takeWhile(BooleanCondition<? super Object> predicate) {
      return this;
    }
  }
}
